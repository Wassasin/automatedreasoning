\documentclass[12pt]{article}
\usepackage{a4wide}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{epic}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{tikz}
%\pagestyle{empty}
\newcommand{\tr}{\mbox{\sf true}}
\newcommand{\fa}{\mbox{\sf false}}
\newcommand{\bimp}{\leftrightarrow}

\begin{document}
\section*{Automated Reasoning\\Assignment 2}

\begin{center}
Wouter Geraedts (s0814857) \\
Judith van Stegeren (s3014827)\\
\end{center}

\vspace{8mm}

\subsection*{Parallel execution}
\paragraph{The problem}
$P$ is the process
\[\texttt{while true do \{x := c; x:= x + c; c := x;\}}\]
Consider the parallel composition $P~\|~P$ in which $x$ is 
local and $c$ is global.
Show that it is possible that executing $P~\|~P$ starting from 
$c=1$ may reach $c=99$, 
and give the consecutive values of the variable $c$ 
before this value $c=99$ is reached.

\paragraph{Solution}
We have solved this problem using NuSMV. 
We started out by defining a module \texttt{powersoftwo} for the program $P$.
Since we want to simulate parallel execution, 
we have to take into account that the program is not executed all at once. 
In this module we have a variable $i$ 
that registers which of the three lines of code will be executed 
if this instance of $P$ gets some computation time.
Because the program runs this code in a loop, this program counter behaves as a ring.
\[\texttt{next(i) := (i + 1) mod 3;}\]
Since the variable $x$ is local, every instance of $P$ also has its own instance of $x$.
This variable is assigned depending on the value of the program counter.
\[
    \begin{array}{ll}
        \texttt{next(x)} & \texttt{:= case} \\
            & \texttt{i = 0 : c;} \\
            & \texttt{i = 1 : x + c <= bound ? x + c : bound;} \\
            & \texttt{TRUE : x;}\\
        \texttt{esac;}
    \end{array}
\]

With the \texttt{next()} function we define the body of the program $P$: every time the module is called, one line from the program $P$ will be executed by the module.

Secondly, we have a module \texttt{main} where
the global variable $c$ is stored, 
together with two instances $p1$, $p2$ of the module \texttt{powersoftwo}.
By using the \texttt{process} keyword, 
we ask NuSMV to repeatedly choose non-deterministically 
between these two processes. 
This way we effectively simulate parallel execution.

\paragraph{Remark}
Because NuSMV employs bounded model checking, we need to explicitly give a bound for the integer values $x_1$, $x_2$ and $c$.
Once the value of variable $x$ increases beyond the value under search, it can no longer attribute to the search.
This because all variables are strictly positive, and only addition is used.
Note that the value of $x$ is not monotonically increasing, because an older, lower, value can still be assigned.
We decided to set the maximum value to $100$ when searching for $c = 99$.
Whenever the value of $x$ increases beyond this point, the maximum value is kept.
\[\texttt{x + c <= bound ? x + c : bound;}\]

\paragraph{Generalization}
In our solution the search value $99$ is a constant definition, so that the bound can be adjusted easily across all modules.
Adding an extra \texttt{powersoftwo} instance is trivial, as it only requires the declaration of this new instance.
\[\texttt{needle := 99; bound := needle + 1;}\]

\paragraph{Results}
We found the solution to the problem by asking NuSMV 
to verify the following CTL specification:
\[\texttt{CTLSPEC AG !(c=99)}\]
which states that it's never possible that c reaches the value 99.
NuSMV proved the statement false and 
provided us with a trace as a counter-example.

The consecutive values of $c$ before it reaches $99$ are as follows:
\begin{verbatim}
  c = 1
  c = 2
  c = 3
  c = 6
  c = 12
  c = 24
  c = 48
  c = 51
  c = 99
\end{verbatim}

NuSMV found this counterexample in 3.2 seconds.

\clearpage

\subsection*{Villages and food}
\paragraph{The problem}Three villages A, B and C consume one food package per time unit. 
Food packages are delivered by a truck. 

We need to solve the following problems:
\begin{enumerate}
\item Show that it's impossible to deliver food packages in such a way that 
forever each of the villages may consume one food package per time unit 
(ie. no starvation);
\item Show that, 
if the capacity of the truck is increased to 320 food packages, 
it is possible that forever each of the villages 
may consume one food package per time unit;
\item Figure out what happens if the capacity of the truck is increased to 318 food packages.
\end{enumerate}

\paragraph{Representation} We start out by defining a module \texttt{village} that registers the maximum capacity and the supply of food packages for a village.
We also have a module \texttt{truck} that registers 
the capacity and supply of food packages of the truck and 
the location of the truck on the graph (A, B, C or S).
Finally, we have the \texttt{main} module, 
where we implemented a state machine to deal with the 
rest of the scenario of the problem:
the \texttt{main} module has 3 instances of \texttt{village}, 
one \texttt{truck}, 
and a variable \emph{state} that registers the state of the truck. 
The truck can be in one of the following states:
\[\texttt{state : \{Decision, traveltoA, traveltoB, traveltoC, traveltoS, Load, Unload\}}\]

\paragraph{Decision state} Decision is the neutral state. 
We return to this state every time an action is completed. 
Where we can go from the Decision state is dependent on 
the location of the truck and the supply of food packages left:\\

\begin{tabular}{|l|p{12cm}|}
\hline
Decision $\rightarrow$ traveltoA & the current location of the truck is a neighbour of village A\\
Decision $\rightarrow$ traveltoB & the current location of the truck is a neighbour of village B\\
Decision $\rightarrow$ traveltoC & the current location of the truck is a neighbour of village C\\
Decision $\rightarrow$ traveltoS & the current location of the truck is a neighbour of village S\\
Decision $\rightarrow$ Load & the truck is in S and the supply of food packages
	is less than the maximum capacity of the truck\\
Decision $\rightarrow$ Unload & the truck is in one of the villages, 
	the village is not at maximum capacity and 
	the truck is not empty\\
\hline
\end{tabular}\\

\paragraph{Action state} When we've chosen an action, we update all variables according to the state we're in:\\

\begin{tabular}{|l|p{12cm}|}
\hline
variable changes&\\
traveltoA & all villages consume food packages 
	depending on the time it takes the truck to reach this location\\
traveltoB & all villages consume food packages\\
traveltoC & all villages consume food packages\\
traveltoS & all villages consume food packages\\
Load & truck supply is at maximum capacity\\ 
Unload & village supply of food packages increases, 
	truck supply decreases\\
\hline
\end{tabular}

When all variables are updated according to the current state, 
the state returns to the value Decision.
Finally we added predicates \texttt{starvation} for every villages, which are true when the village has run out of food packages to consume.

\paragraph{Remark about unloading} At first, we let the NuSMV choose how much packages the truck would unload in a village by stating that every Unload action would transfer only one packages from the truck to the village. By choosing Unload multiple times before choosing a Travel state, the truck would unload multiple packages.

Because of this, the state space became quite big and it took NuSMV 40 hours to check our model.

We then reduced the state space by changing the Unload action as follows: the truck now unloads as much food packages as possible, either until the truck is empty or the village is full. NuSMV then took only 20 minutes to check the model.

\paragraph{Answers} NuSMV found the following answers to the questions:
\begin{enumerate}
\item We asked NuSMV to check the CTL specification
\[ \texttt{AF ((village\_A.starvation | village\_B.starvation) | village\_C.
starvation)} \]
which states that every trace eventually ends up in a state where one of the villages can no longer consume a food package.
NuSMV returned \texttt{true} after 18 minutes.

\item We changed the truck capacity to 320 and checked the CTL specification
\[ \texttt{EG !((village\_A.starvation | village\_B.starvation) | village\_C.starvation)} \]
which states that there is a trace where we never encounter starvation.
NuSMV returned \texttt{true} after 19 minutes.

\item We changed the truck capacity to 318 and checked the CTL specification
\[\texttt{EG !((village\_A.starvation | village\_B.starvation) | village\_C.starvation)} \]
NuSMV returned \texttt{false} after 12 minutes.
\end{enumerate}

\clearpage

\subsection*{Alternating bit protocol}
\paragraph{The problem} We have a description of the alternating bit protocol,
which makes use of two memory places $A$ and $C$, two channels $B$ and $D$ and two locations $S$ and $R$. We have to prove correctness of the described protocol.

\paragraph{Representation} We start out by defining a module \texttt{channel} 
for $B$ and $D$, in which we register the values $f$ and $b$ and the value $B_{datum}$.
We also have a module \texttt{alternatingbitcell} for $S$ and $R$ 
where we register the value of $b$. 
Finally we have a module for the sequences $A_{seq}$ and $B_{seq}$ since NuSMV is not very good at dealing with arrays.

\paragraph{State machine} We have implemented the protocol as a state machine 
based on the steps A,B,C,D,E,F from the description of the protocol. 
In the main module, we have a variable \texttt{step}
that registers the current state of the state machine, 
that can have the following values:
\[ \texttt{step : \{Decision, stepA, stepB, stepC, stepD, stepE, stepF\};}\]

We start out in the Decision state. 
From the Decision state, we non-deterministically choose one of the steps. 
Which steps are valid depends on the contents of $S$, $R$, $D$ and $B$.
Steps A-D can always happen. 
For E and F there are some extra requirements. 

\paragraph{Variable changes}
Whenever we are in a state that corresponds to one of the steps A-F, 
we alter the contents of $S$, $R$, $D$ and $B$ according 
to the description of the protocol:\\

\begin{tabular}{|l|p{12cm}|}
\hline
StepA & $B_f$ is false\\
StepB & $D_f$ is false\\
StepC & $B_b := S_b$, $B_{datum} = A_{seq}[i]$, $B_f$ is true\\
StepD & $D_b := !R_b$, $D_f$ is true; \\
StepE & Reading index $i$ of $A_{seq}$ is incremented, $S_b := !S_b$\\
StepF & $C_{seq} := B_{datum}$, writing index $i$ of $C_{seq}$ is incremented.\\
\hline
\end{tabular}

After updating all relevant variables we return to the Decision state.

\paragraph{Correctness} To prove the correctness of the protocol, 
we added a predicate \texttt{C\_seq\_full} that is true 
whenever $C_{seq}$ has the same length $n$ as $A_{seq}$, 
and a predicate \texttt{Aseq\_Cseq\_equal} that is true 
if the contents of $A_{seq}$ and $C_{seq}$ are exactly the same.

Then we asked NuSMV to check the following CTL specification:
\[ \texttt{CTLSPEC AG (Cseq\_full -> Aseq\_Cseq\_eq)} \]
NuSMV returned \texttt{true}.



\end{document}
